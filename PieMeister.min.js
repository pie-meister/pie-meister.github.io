export default class t extends HTMLElement {
  connectedCallback() {
    this.svg(this.attachShadow({ mode: `open` }));
  }
  svg(
    t,
    e = (this.getAttribute`stroke` || `#e33,#3e3,#35e,#ee3,#e5e,#3ee`).split`,`,
    i = ~~this.getAttribute`pull`,
    s = ~~this.getAttribute`gap`,
    r = 0,
    l = 0
  ) {
    setTimeout((u) => {
      t.innerHTML = `<style>:host{display:inline-block}svg{width:100%}</style><svg xmlns=http://www.w3.org/2000/svg viewBox=0,0,${
        1e3 + i
      },${1e3 + i}>${this.innerHTML}</svg>`;
      this.$ = [...t.querySelectorAll`slice`].map((t, u) => {
        let a = document.createElementNS(`http://www.w3.org/2000/svg`, `g`),
          h = document.createElementNS(`http://www.w3.org/2000/svg`, `text`),
          n = t.getAttribute`size`,
          p = ~~n.replace(`%`, ``),
          o =
            ~~t.getAttribute`stroke-width` ||
            ~~this.getAttribute`stroke-width` ||
            500 + i / 2 - i,
          g = r;
        a.create = (
          s = 0,
          r = o,
          u = t.getAttribute(`stroke`) || (0 == s && e.shift()),
          h = p,
          n = g,
          b = (500 + i / 2) / 2 -
            i / 2 +
            s -
            (`stroke-width` == this.getAttribute`fill`
              ? (500 - i / 2 - r) / 2
              : 0),
          A = document.createElementNS(`http://www.w3.org/2000/svg`, `path`)
        ) => (
          A.setAttribute(`stroke`, u),
          A.setAttribute(`stroke-width`, r),
          A.setAttribute(`pathLength`, l),
          A.setAttribute(`stroke-dasharray`, h + ` ` + (l - h)),
          A.setAttribute(`stroke-dashoffset`, n + h),
          A.setAttribute(
            `d`,
            `m${500 + i / 2} ${500 + i / 2}m0 ${-b}a2 2 0 000 ${
              2 * b
            }a2 2 0 000-${2 * b}`
          ),
          A.setAttribute(`fill`, `none`),
          (A.width = r),
          (A.point = (t = 0, e) =>
            e
              ? a.create(e).point(t)
              : A.getPointAtLength(
                  A.getTotalLength() -
                    (A.getTotalLength() / l) * (t + (g + h / 2))
                )),
          A
        );
        p == n
          ? l ||
            [...this.querySelectorAll`slice`].map(
              (t) => (l += ~~t.getAttribute`size` + s)
            )
          : (l = ~~this.getAttribute`size` || 100);
        p || ((p = l - r), (n = p + `%`));
        a.path = a.create(0);
        a.onmouseout = (t) => (
          (this.slice = a), this.dispatchEvent(new Event(`slice`), a.pull(0))
        );
        a.onmouseover = (t) => (
          (this.slice = a), this.dispatchEvent(new Event(`slice`), a.pull(1))
        );
        a.setAttribute(`size`, n);
        a.setAttribute(`slice`, u + 1);
        a.setAttribute(
          `label`,
          (h.innerHTML = this.querySelector`style`
            ? (t.innerHTML && t.innerHTML.replace(`size`, n)) || n
            : ``)
        );
        a.path.setAttribute(`stroke-dashoffset`, (r += p + s));
        [...t.attributes].map((t) => a.path.setAttribute(t.name, t.value));
        h.setAttribute(
          `y`,
          a.path.point(
            0,
            ~~t.getAttribute`pulltext` || ~~this.getAttribute`pulltext` || 0
          ).y
        );
        h.setAttribute(
          `x`,
          a.path.point(
            0,
            ~~t.getAttribute`pulltext` || ~~this.getAttribute`pulltext` || 0
          ).x
        );
        a.append(a.path, h);
        t.parentNode.replaceChild(a, t);
        a.pull = (
          e = t.hasAttribute`pull`,
          s = Math.abs(~~t.getAttribute`pull` || i)
        ) =>
          a.setAttribute(
            `transform`,
            (a.pulled = e)
              ? `translate(${a.path.point(0, s).x - a.path.point().x} ${
                  a.path.point(0, s).y - a.path.point().y
                })`
              : ``
          );
        a.pull();
        return a;
      });
    });
  }
}
